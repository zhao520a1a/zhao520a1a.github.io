<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Go JSON 三方包哪家强？ | 发光の金子吖</title><meta name="author" content="Golden"><meta name="copyright" content="Golden"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="引言为了小伙伴理解，汇总了一下文章中会提及的术语名词解释，请耐心品读，欢迎一起讨论交流！    专业术语 名词解释    JIT 即时编译   code-gen 代码生成   lazy-load 按需加载&#x2F;懒加载   ast 抽象语法树(Abstract Syntax Tree )   Clang 它是一个 C&#x2F;C++ 的轻量级编译器   asm 汇编语言(Assembly l">
<meta property="og:type" content="article">
<meta property="og:title" content="Go JSON 三方包哪家强？">
<meta property="og:url" content="https://zhao520a1a.github.io/2023/05/09/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/Go/Go%20JSON%20%E4%B8%89%E6%96%B9%E5%8C%85%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/index.html">
<meta property="og:site_name" content="发光の金子吖">
<meta property="og:description" content="引言为了小伙伴理解，汇总了一下文章中会提及的术语名词解释，请耐心品读，欢迎一起讨论交流！    专业术语 名词解释    JIT 即时编译   code-gen 代码生成   lazy-load 按需加载&#x2F;懒加载   ast 抽象语法树(Abstract Syntax Tree )   Clang 它是一个 C&#x2F;C++ 的轻量级编译器   asm 汇编语言(Assembly l">
<meta property="og:locale">
<meta property="og:image" content="https://cms.halovina.com/wp-content/uploads/2021/03/golang-json.jpg">
<meta property="article:published_time" content="2023-05-08T16:00:00.000Z">
<meta property="article:modified_time" content="2023-05-16T14:01:59.155Z">
<meta property="article:author" content="Golden">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cms.halovina.com/wp-content/uploads/2021/03/golang-json.jpg"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://zhao520a1a.github.io/2023/05/09/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/Go/Go%20JSON%20%E4%B8%89%E6%96%B9%E5%8C%85%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go JSON 三方包哪家强？',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-16 22:01:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cms.halovina.com/wp-content/uploads/2021/03/golang-json.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="发光の金子吖"><img class="site-icon" src="/img/logo.png"/><span class="site-name">发光の金子吖</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go JSON 三方包哪家强？</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-08T16:00:00.000Z" title="发表于 2023-05-09 00:00:00">2023-05-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-16T14:01:59.155Z" title="更新于 2023-05-16 22:01:59">2023-05-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/">内部原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Go JSON 三方包哪家强？"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>为了小伙伴理解，汇总了一下文章中会提及的术语名词解释，请耐心品读，欢迎一起讨论交流！</p>
<table>
<thead>
<tr>
<th><strong>专业术语</strong></th>
<th><strong>名词解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>JIT</td>
<td>即时编译</td>
</tr>
<tr>
<td>code-gen</td>
<td>代码生成</td>
</tr>
<tr>
<td>lazy-load</td>
<td>按需加载&#x2F;懒加载</td>
</tr>
<tr>
<td>ast</td>
<td>抽象语法树(Abstract Syntax Tree )</td>
</tr>
<tr>
<td>Clang</td>
<td>它是一个 C&#x2F;C++ 的轻量级编译器</td>
</tr>
<tr>
<td>asm</td>
<td>汇编语言(Assembly language)</td>
</tr>
<tr>
<td>Plan9</td>
<td>它是一个 Unix 系统，其中 Go 底层使用的汇编语言是 plan9 汇编</td>
</tr>
<tr>
<td>SIMD</td>
<td>全称单指令流多数据流(Single-Instruction-Multi-Data)它是一组特殊的 CPU 指令，用于矢量数据的并行处理</td>
</tr>
</tbody></table>
<h2 id="你真的了解-Go-标准库吗？"><a href="#你真的了解-Go-标准库吗？" class="headerlink" title="你真的了解 Go 标准库吗？"></a>你真的了解 Go 标准库吗？</h2><p>问题一：标准库可以反序列化普通的字符串吗？执行下面的代码会报错吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(<span class="string">`&quot;Hello, world!&quot;`</span>), &amp;s)</span><br><span class="line">assert.NoError(t, err)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Hello, world!</span></span><br></pre></td></tr></table></figure>

<p>解：其实标准库解析不仅支持是对象、数组，同时也可以是字符串、数值、布尔值以及空值，但需要注意，上面字符串中的双引号不能缺，否则将不是一个合法的 json 序列，会返回错误。</p>
<p>问题二：如果结构体的 json tag 定义与 key 大小不一致，可以反序列化成功吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cert := <span class="keyword">struct</span> &#123;</span><br><span class="line">    Username <span class="type">string</span> <span class="string">`json:&quot;username&quot;`</span></span><br><span class="line">    Password <span class="type">string</span> <span class="string">`json:&quot;password&quot;`</span></span><br><span class="line">&#125;&#123;&#125;</span><br><span class="line">err = json.Unmarshal([]<span class="type">byte</span>(<span class="string">`&#123;&quot;UserName&quot;:&quot;root&quot;,&quot;passWord&quot;:&quot;123456&quot;&#125;`</span>), &amp;cert)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;username =&quot;</span>, cert.Username)</span><br><span class="line">    fmt.Println(<span class="string">&quot;password =&quot;</span>, cert.Password)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// username = root</span></span><br><span class="line"><span class="comment">// password = 123456</span></span><br></pre></td></tr></table></figure>

<p>解：如果遇到大小写问题，标准库会尽可能地进行大小写转换，即：一个 key 与结构体中的定义不同，但忽略大小写后是相同的，那么依然能够为字段赋值</p>
<h2 id="为什么使用第三方库，标准库有哪些不足？"><a href="#为什么使用第三方库，标准库有哪些不足？" class="headerlink" title="为什么使用第三方库，标准库有哪些不足？"></a>为什么使用第三方库，标准库有哪些不足？</h2><p>Go json 标准库 <a target="_blank" rel="noopener" href="https://pkg.go.dev/encoding/json">encoding&#x2F;json</a>已经是提供了足够舒适的 json 处理工具，广受 Go 开发者的好评，但还是存在以下两点问题：</p>
<ul>
<li>API 不够灵活：如没有提供按需加载机制等；</li>
<li>性能不太高：标准库大量使用反射获取值，首先 Go 的反射本身性能较差，较耗费 CPU 配置；其次频繁分配对象，也会带来内存分配和 GC 的开销；</li>
</ul>
<p>因业务使用场景和降本收益等诉求，不可避免需要引入合适的第三方库。</p>
<h1 id="评测三方库"><a href="#评测三方库" class="headerlink" title="评测三方库"></a>评测三方库</h1><p>下面开始灵魂三问：</p>
<ul>
<li><strong>热门的三方库有哪些？</strong></li>
<li><strong>内部实现原理是什么？</strong></li>
<li><strong>如何结合业务去选型？</strong></li>
</ul>
<p>下面是收集整理的一些开源第三方库，也欢迎有兴趣的小伙伴一起交流补充！</p>
<table>
<thead>
<tr>
<th><strong>库名</strong></th>
<th><strong>encoder</strong></th>
<th><strong>decoder</strong></th>
<th><strong>compatible</strong></th>
<th><strong>star 数 (2023.04.19)</strong></th>
<th><strong>社区维护性</strong></th>
</tr>
</thead>
<tbody><tr>
<td>StdLib(<a target="_blank" rel="noopener" href="https://pkg.go.dev/encoding/json">encoding&#x2F;json</a>)</td>
<td>✔️</td>
<td>✔️</td>
<td>N&#x2F;A</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>FastJson(<a target="_blank" rel="noopener" href="https://github.com/valyala/fastjson">valyala&#x2F;fastjson</a>)</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>1.9k</td>
<td>较差</td>
</tr>
<tr>
<td>GJson(<a target="_blank" rel="noopener" href="https://github.com/tidwall/gjson">tidwall&#x2F;gjson</a>)</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>12.1k</td>
<td>较好</td>
</tr>
<tr>
<td>JsonParser(<a target="_blank" rel="noopener" href="https://github.com/buger/jsonparser">buger&#x2F;jsonparser</a>)</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>5k</td>
<td>较差</td>
</tr>
<tr>
<td>JsonIter(<a target="_blank" rel="noopener" href="https://github.com/json-iterator/go">json-iterator&#x2F;go</a>)</td>
<td>✔️</td>
<td>✔️</td>
<td>部分兼容</td>
<td>12.1k</td>
<td>较差</td>
</tr>
<tr>
<td>GoJson(<a target="_blank" rel="noopener" href="https://github.com/goccy/go-json">goccy&#x2F;go-json</a>)</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>2.2k</td>
<td>较好</td>
</tr>
<tr>
<td>EasyJson(<a target="_blank" rel="noopener" href="https://github.com/mailru/easyjson">mailru&#x2F;easyjson</a>)</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>4.1k</td>
<td>较差</td>
</tr>
<tr>
<td>Sonic(<a target="_blank" rel="noopener" href="https://github.com/bytedance/sonic">bytedance&#x2F;sonic</a>)</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>4.1k</td>
<td>较好</td>
</tr>
</tbody></table>
<h2 id="评判标准"><a href="#评判标准" class="headerlink" title="评判标准"></a>评判标准</h2><p>评判标准包含三个维度：</p>
<ul>
<li>性能：内部实现原理是什么，是否使用反射机制；</li>
<li>稳定性：考虑到要投入生产使用，必须是一个较为稳定的三方库；</li>
<li>功能灵活性：是否支持 Unmarshal 到 map 或 struct，是否提供的一些定制化抽取的 API；</li>
</ul>
<p>在功能划分上，根据主流 json 库 API，将它们的使用方式分为三种：</p>
<ul>
<li><strong>泛型（generic）编解码</strong>：json 没有对应的 schema，只能依据自描述语义将读取到的 value 解释为对应语言的运行时对象，例如：json object 转化为 Go map[string]interface{}；</li>
<li><strong>定型（binding）编解码</strong>：json 有对应的 schema，可以同时结合模型定义（Go struct）与 json 语法，将读取到的 value 绑定到对应的模型字段上去，同时完成数据解析与校验；</li>
<li><strong>查找（get）&amp; 修改（set）</strong>：指定某种规则的查找路径（一般是 key 与 index 的集合），获取需要的那部分 json value 并处理。</li>
</ul>
<h2 id="功能评测"><a href="#功能评测" class="headerlink" title="功能评测"></a>功能评测</h2><table>
<thead>
<tr>
<th><strong>相关库</strong></th>
<th><strong>unmarshal (interface)</strong></th>
<th><strong>unmarshal (struct)</strong></th>
<th><strong>get&amp;set</strong></th>
<th><strong>stream</strong></th>
</tr>
</thead>
<tbody><tr>
<td>StdLib</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>✔️</td>
</tr>
<tr>
<td>FastJson</td>
<td>❌</td>
<td>❌</td>
<td>✔️</td>
<td>❌</td>
</tr>
<tr>
<td>Gjson</td>
<td>✔️</td>
<td>❌</td>
<td>✔️</td>
<td>❌</td>
</tr>
<tr>
<td>JsonParser</td>
<td>❌</td>
<td>❌</td>
<td>✔️</td>
<td>❌</td>
</tr>
<tr>
<td>EasyJson</td>
<td>-</td>
<td>✔️</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>JsonIter</td>
<td>✔️</td>
<td>❌</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>GoJson</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>✔️</td>
</tr>
<tr>
<td>Sonic</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="特点分析"><a href="#特点分析" class="headerlink" title="特点分析"></a>特点分析</h2><table>
<thead>
<tr>
<th>类别</th>
<th>备注</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>比标准库功能丰富</td>
<td>在功能和使用方式上有别于标准库。通过遍历 json 字符串的字节来挨个解析,返回其值 []byte，由业务方自行处理，牺牲了一定的兼容性，但功能上各有特色。<br>相关库<br>- FastJson 的 api 操作最简单；<br>- Gjson 提供了模糊查找的功能，自定义程度最高；<br>- JsonParser 可以插入回调函数执行，提供了一定程度上的便利</td>
<td></td>
</tr>
<tr>
<td>比标准库性能好</td>
<td>通过代码生成的方式，不使用反射，使用上类似 protobuf 为每一个结构体生成序列化的代码，因此具有强入侵性；<br>相关库：EasyJson</td>
<td></td>
</tr>
<tr>
<td>比标准库性能较好，且兼容性较好</td>
<td>在功能和使用方式上有兼容标准库，且通过尽量减少反射的使用来提高性能。<br>相关库：JsonIter、GoJson、Sonic…</td>
<td></td>
</tr>
</tbody></table>
<h2 id="性能评测"><a href="#性能评测" class="headerlink" title="性能评测"></a>性能评测</h2><p>下面是评测性能时所用的各个包的版本情况，具体的测试代码，可参考<a target="_blank" rel="noopener" href="https://github.com/zhao520a1a/go-base/blob/master/json/benchmark_test/bench.sh">benchmark_test</a> ，欢迎友好交流。</p>
<table>
<thead>
<tr>
<th><strong>库名</strong></th>
<th><strong>version</strong></th>
</tr>
</thead>
<tbody><tr>
<td>StdLib</td>
<td>v1.19</td>
</tr>
<tr>
<td>JsonIter</td>
<td>v1.1.13</td>
</tr>
<tr>
<td>GoJson</td>
<td>v0.10.1</td>
</tr>
<tr>
<td>Sonic</td>
<td>v1.8.3</td>
</tr>
</tbody></table>
<p><strong>为什么没有评测 GJson 库呢?</strong></p>
<p>GJson 在单键查找的场景下有很大的优势。这是因为它的查找是通过 lazy-load 实现的，它巧妙地跳过了传递值，有效地减少了很多不必要的解析，但其实跳过也是一种轻量级解析，实际是在处理 json 控制字符“[”、“{”等；然而当涉及到多键查找时，Gjson 做的事比标准库更糟糕，这是其跳过机制的副作用：相同路径查找导致的重复开销。针对它的使用场景，单纯的评测定性编解码和泛型编解码，对 GJson 是不公平的。</p>
<p>根据样本 json 的 key 数量和深度分为三个量级：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/zhao520a1a/go-base/blob/master/json/testdata/small.go">Small</a>(400B, 11 keys, 3 layers)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/zhao520a1a/go-base/blob/master/json/testdata/medium.go">Medium</a>(13KB, 300+ key, 6 layers)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/zhao520a1a/go-base/blob/master/json/testdata/large.json">Large</a>(635KB, 10000+ key, 6 layers)</li>
</ul>
<p>评测过程中，需要注意不但要区分泛型编&#x2F;解码&amp;定型编&#x2F;解码，而且也要考虑到并发情况下的性能表现，下面是测试代码样例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkEncoder_Generic_StdLib</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    _, _ = json.Marshal(_GenericValue)</span><br><span class="line">    b.SetBytes(<span class="type">int64</span>(<span class="built_in">len</span>(TwitterJson)))</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        _, _ = json.Marshal(_GenericValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkEncoder_Binding_StdLib</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    _, _ = json.Marshal(&amp;_BindingValue)</span><br><span class="line">    b.SetBytes(<span class="type">int64</span>(<span class="built_in">len</span>(TwitterJson)))</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        _, _ = json.Marshal(&amp;_BindingValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkEncoder_Parallel_Generic_StdLib</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    _, _ = json.Marshal(_GenericValue)</span><br><span class="line">    b.SetBytes(<span class="type">int64</span>(<span class="built_in">len</span>(TwitterJson)))</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">            _, _ = json.Marshal(_GenericValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkEncoder_Parallel_Binding_StdLib</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    _, _ = json.Marshal(&amp;_BindingValue)</span><br><span class="line">    b.SetBytes(<span class="type">int64</span>(<span class="built_in">len</span>(TwitterJson)))</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">            _, _ = json.Marshal(&amp;_BindingValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的指标数据和统计结果，可参考<a target="_blank" rel="noopener" href="https://github.com/zhao520a1a/go-base/blob/master/json/benchmark_test/README.md">benchmark_readme</a> ，大体结论如下：</p>
<table>
<thead>
<tr>
<th><strong>库名</strong></th>
<th><strong>数据量</strong></th>
<th><strong>泛型编码**性能**</strong></th>
<th><strong>定型编码性能</strong></th>
<th><strong>泛型解码</strong></th>
<th><strong>定型解码</strong></th>
</tr>
</thead>
<tbody><tr>
<td>StdLib</td>
<td>小</td>
<td>⭐️</td>
<td>⭐️</td>
<td>⭐️⭐️</td>
<td>⭐️</td>
</tr>
<tr>
<td>-</td>
<td>中</td>
<td>⭐️</td>
<td>⭐️</td>
<td>⭐️</td>
<td>⭐️</td>
</tr>
<tr>
<td>-</td>
<td>大</td>
<td>⭐️</td>
<td>⭐️</td>
<td>⭐️</td>
<td>⭐️</td>
</tr>
<tr>
<td>JsonIter</td>
<td>小</td>
<td>⭐️⭐️⭐️</td>
<td>⭐️</td>
<td>⭐️⭐️</td>
<td>⭐️⭐️⭐️</td>
</tr>
<tr>
<td>-</td>
<td>中</td>
<td>⭐️⭐️⭐️</td>
<td>⭐️</td>
<td>⭐️⭐️</td>
<td>⭐️⭐️</td>
</tr>
<tr>
<td>-</td>
<td>大</td>
<td>⭐️⭐️⭐️⭐</td>
<td>⭐️</td>
<td>⭐️⭐️</td>
<td>⭐️⭐️</td>
</tr>
<tr>
<td>GoJson</td>
<td>小</td>
<td>⭐️⭐️⭐️</td>
<td>⭐️⭐️</td>
<td>⭐️</td>
<td>⭐️⭐️⭐️</td>
</tr>
<tr>
<td>-</td>
<td>中</td>
<td>⭐️⭐️</td>
<td>⭐️⭐️⭐️</td>
<td>⭐️⭐️⭐️</td>
<td>⭐️⭐️⭐️⭐️</td>
</tr>
<tr>
<td>-</td>
<td>大</td>
<td>⭐️⭐️⭐️</td>
<td>⭐️⭐️⭐️</td>
<td>⭐️⭐️⭐️</td>
<td>⭐️⭐️⭐️⭐️</td>
</tr>
<tr>
<td>Sonic</td>
<td>小</td>
<td>⭐️⭐️⭐️⭐</td>
<td>⭐️⭐️⭐️⭐️</td>
<td>⭐️⭐️⭐️⭐️</td>
<td>⭐️⭐️⭐️⭐️</td>
</tr>
<tr>
<td>-</td>
<td>中</td>
<td>⭐️⭐️⭐️⭐️</td>
<td>⭐️⭐️⭐️⭐️</td>
<td>⭐️⭐️⭐️⭐️</td>
<td>⭐️⭐️⭐️⭐️</td>
</tr>
<tr>
<td>-</td>
<td>大</td>
<td>⭐️⭐️⭐️⭐</td>
<td>⭐️⭐️⭐️⭐</td>
<td>⭐️⭐️⭐️⭐️</td>
<td>⭐️⭐️⭐️⭐️</td>
</tr>
</tbody></table>
<h1 id="常见优化思路"><a href="#常见优化思路" class="headerlink" title="常见优化思路"></a>常见优化思路</h1><h2 id="定型编解码"><a href="#定型编解码" class="headerlink" title="定型编解码"></a>定型编解码</h2><p>对于有 schema 的定型编解码场景而言，很多运算其实不需要在“运行时”执行。例如业务模型中确定了某个 json key 的值一定是布尔类型，其实可以在序列化阶段直接输出这个对象对应的 json 值(true&#x2F;false)，并不需要再检查这个对象的具体类型。其核心思想是<strong>优化数据处理逻辑，将模型解释与数据处理逻辑分离，让前者提前固定下来，进而消除反射，提升性能。</strong></p>
<h3 id="动态函数组装"><a href="#动态函数组装" class="headerlink" title="动态函数组装"></a>动态函数组装</h3><p>JsonIter 就使用函数组装模式，具体方法是将结构解释为逐个字段的编码和解码函数，然后将其组装并缓存为整个对象对应的编解码器，运行时再加载出来处理 json，将反射的性能损失成本降到最低。</p>
<p>这样优化是否就能一劳永逸呢？</p>
<p>并没有。因为这样实现会转化为大量的接口封装和函数调用栈。在实际测试中，会发现随着 json 数据量级的增长，因为调用接口涉及动态寻址，汇编函数不能被内联，而 Golang 的函数调用性能很差（没有逐个寄存器的参数传递），函数调用的开销也会成倍放大。</p>
<h3 id="减少函数调用"><a href="#减少函数调用" class="headerlink" title="减少函数调用"></a>减少函数调用</h3><p>为了避免动态汇编的函数调用开销，业界实现方式目前主要有两种：code-gen（代码生成 ） 和 JIT（ 即时编译）。</p>
<h3 id="code-gen"><a href="#code-gen" class="headerlink" title="code-gen"></a>code-gen</h3><p>这种实现方式库开发者实现起来相对简单，性能高，但是它伴随着模式依赖性和便利性的损失，增加业务代码的维护成本和局限性，无法做到秒级热更新，这也是代码生成方式的 json 库受众并不广泛的原因。例如 EasyJson 就采用代码生成的思路。</p>
<h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p>即时编译将编译过程移到了程序的加载或首次解析阶段，只需要提供 json schema 对应的结构体类型信息，就可以一次性编译生成对应的编解码器，通常以 Golang 函数的形式缓存到堆外内存，便于后期高效执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数缓存</span></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">  functions <span class="keyword">map</span>[*rtype]function</span><br><span class="line">  lock      sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  global = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> [caches]*cache &#123;</span><br><span class="line">    <span class="keyword">var</span> caches [caches]*cache</span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> caches &#123;</span><br><span class="line">      caches[idx] = &amp;cache&#123;functions: <span class="built_in">make</span>(<span class="keyword">map</span>[*rtype]function, <span class="number">4</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> caches</span><br><span class="line">  &#125;()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(typ *rtype)</span></span> (function, <span class="type">bool</span>) &#123;</span><br><span class="line">  do, ok := global[<span class="type">uintptr</span>(unsafe.Pointer(typ))%caches].functions[typ]</span><br><span class="line">  <span class="keyword">return</span> do, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">(typ *rtype, do function)</span></span> &#123;</span><br><span class="line">  cache := global[<span class="type">uintptr</span>(unsafe.Pointer(typ))%caches]</span><br><span class="line">  cache.lock.Lock()</span><br><span class="line">  cache.functions[typ] = do</span><br><span class="line">  cache.lock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型编解码"><a href="#泛型编解码" class="headerlink" title="泛型编解码"></a>泛型编解码</h2><p>其实泛型编解码性能差只是因为没有 schema ，因为可以对比一下 C++ 的 json 库，如 <a target="_blank" rel="noopener" href="https://github.com/simdjson/simdjson">simdjson</a>，它的解析方式都是泛型的，但性能仍然很好；</p>
<p>Go 标准库泛型解析性能差，原因在于它采用了 map[string]interface{} 作为 json 的编解码对象。这其实是一种糟糕的选择，原因如下：</p>
<ul>
<li>数据反序列化的过程中，map 插入的开销很高；</li>
<li>在数据序列化过程中，map 遍历也远不如数组高效；</li>
</ul>
<p>如果用一种与 json AST 更贴近的数据结构来描述，不但可以让转换过程更加简单，甚至可以实现 lazy-load 。</p>
<h2 id="复用编码缓存区"><a href="#复用编码缓存区" class="headerlink" title="复用编码缓存区"></a>复用编码缓存区</h2><p>通过使用 sync.Pool 复用先前编码的缓冲区，可以有效减少 encode buffer 的内存分配次数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> buffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bufPool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;buffer&#123;data: <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">1024</span>)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复用缓冲区</span></span><br><span class="line">buf := bufPool.Get().(*buffer)</span><br><span class="line">data := encode(buf.data)</span><br><span class="line">newBuf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(data))</span><br><span class="line"><span class="built_in">copy</span>(newBuf, buf)</span><br><span class="line">buf.data = data</span><br><span class="line">bufPool.Put(buf)</span><br></pre></td></tr></table></figure>

<h1 id="案例-Sonic-库"><a href="#案例-Sonic-库" class="headerlink" title="案例 Sonic 库"></a>案例 Sonic 库</h1><h2 id="原理调研"><a href="#原理调研" class="headerlink" title="原理调研"></a>原理调研</h2><p>Sonic 基于汇编进行开发，通过充分利用向量化（SIMD）指令、优化内存布局和按需解析等关键技术，大幅提高了序列化反序列化性能。针对 Go 语言编译优化的不足，Sonic 核心计算函数使用 C 语言编写，使用 Clang 的深度优化编译选项，并开发了一套 asm2asm 工具，将完全优化的 x86 汇编翻译成 plan9 汇编，加载到 Golang 运行时，以供调用。</p>
<img src="/2023/05/09/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/Go/Go%20JSON%20%E4%B8%89%E6%96%B9%E5%8C%85%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/f8e5e48d-7c17-4447-955d-6ba07d3e8aaf.png" alt="img">

<p><strong>为什么不使用 CGO ？</strong></p>
<p>虽然使用 CGO 实现更加简便， 但 CGO 在调用 c 代码的时候引入了调度、切换线程栈等开销，会造成较大（有的场景中高达 20 多倍）的性能损耗，无法对代码进行了深度优化。</p>
<h3 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h3><p><strong>什么是 SIMD?</strong></p>
<p>SIMD（Single-Instruction-Multi-Data 单指令流多数据流）它是一种采用一个控制器来控制多个处理器，同时对一组数据中的每一个数据分别执行相同的操作，从而实现空间上的并行性技术。例如：X86 的 SSE 或者 AVX2 指令集，以及 ARM 的 NEON 指令集等。它作为一组特殊的 CPU 指令，用于矢量数据的并行处理。目前，它被大多数 CPU 所支持，并广泛用于图像处理和大数据计算中，当然在 json 处理中也很有用。</p>
<p><strong>SIMD 在 json 处理中解决了什么问题？</strong></p>
<p>对于 json 文本的处理与计算。其中一些问题在业界已经有比较成熟高效的解决方案，如浮点数转字符串算法 Ryu，整数转字符串的查表法等；针对一些问题逻辑相对简单，但是可能会面对较大数量级的文本，如 json string 的 unquote\quote 处理、空白字符的跳过等，也需要某种技术手段来提升处理能力，而 SIMD 就是一种用于并行处理大规模数据的技术。<a target="_blank" rel="noopener" href="https://github.com/minio/simdjson-go">simdjson-go</a>在大型 json 场景（&gt;100KB）中非常有竞争力。然而，对于一些极小的或不规则的字符串，SIMD 所需的额外负载操作将导致性能下降。因此， 对于大数据和小数据并存的实际场景，采用预设条件判断（字符串大小、浮动精度等），将 SIMD 和标量指令结合起来，以达到最佳适应性。</p>
<h3 id="asm2asm"><a href="#asm2asm" class="headerlink" title="asm2asm"></a>asm2asm</h3><p>为了提高执行效率，Sonic 中一些关键的计算函数是用 C 编写的，用 Clang 编译的；但由于 Clang 编译出来的是 x86 汇编，而 Golang 编译出来的是 plan9 汇编；那如何将优化后的汇编嵌入 Golang 中就变成了一个问题，因此为了在 Golang 中调用 Clang 编译出来的汇编，字节开发了一个内部工具 tools&#x2F;asm2asm 将 x86 的汇编转换为 plan9。</p>
<h3 id="JIT-汇编"><a href="#JIT-汇编" class="headerlink" title="JIT 汇编"></a>JIT 汇编</h3><p>Sonic 借鉴 JsonIter 的组装各类型处理函数的实现，针对编解码器动态装配的函数调用开销，采用 JIT 技术在运行时对模式对应的操作码（asm）进行装配，最后以 Golang 函数的形式缓存到堆外内存。因为编译后的编解码函数是一个集成函数，可以大大减少函数调用，同时保证灵活性；对于 json 对应的结构体已知的服务场景，在线进行 JIT 汇编是比较耗时的，会导致首次请求耗时较高，也可以预先生成好汇编后的字节码。</p>
<h3 id="RCU-cache"><a href="#RCU-cache" class="headerlink" title="RCU cache"></a>RCU cache</h3><p>为了提升 Codec Cache 的加载速度，每个结构体对应的序列化&#x2F;反序列化字节码可以缓存起来，后面直接调用，以减少运行时汇编操作的执行次数（缓存足够大的时候只需要执行一次）。Sync.Map 最初是用来缓存编解码器的，但对于准静态（读远多于写）、较少元素（通常不超过几十个）的场景来说，其性能并不理想，所以用“开放寻址哈希+RCU 技术”重新实现了一个高性能和并发安全的缓存。</p>
<h3 id="自定义-AST"><a href="#自定义-AST" class="headerlink" title="自定义 AST"></a>自定义 AST</h3><p>针对泛型编解码，基于 map 开销较大的考虑，Sonic 实现了更能符合 json 结构的树形 AST；通过自定义的一种通用的泛型数据容器 sonic-ast 替代 Go interface，从而提升性能。用 node {type, length, pointer} 表示任意一个 json 数据节点，并结合树与数组结构描述节点之间的层级关系。针对部分解析，考虑到解析和跳过之间的巨大速度差距，将 lazy-load 机制到 AST 解析器中，以一种更加自适应和高效的方式来减少多键查询的开销。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    v <span class="type">int64</span></span><br><span class="line">    t types.ValueType</span><br><span class="line">    p unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何实现部分解析？</strong> sonic-ast 实现了一种有状态、可伸缩的 json 解析过程。当使用者 get 某个 key 时，采用 skip 计算来轻量化跳过要获取的 key 之前的 json 文本；对于该 key 之后的 json 节点，直接不做任何的解析处理；仅使用者真正需要的 key 才完全解析。另外，在对于子节点 skip 处理过程增加了一个步骤，将跳过 json 的 key、起始位、结束位记录下来，分配一个 Raw-JSON 类型的节点保存下来，这样二次 skip 就可以直接基于节点的 offset 进行，这样解决相同路径查找导致的重复开销的问题。同时 sonic-ast 支持了节点的更新、插入和序列化，甚至支持将任意 Go types 转为节点并保存下来。</p>
<img src="/2023/05/09/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/Go/Go%20JSON%20%E4%B8%89%E6%96%B9%E5%8C%85%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/a20489e8ab7de9fa55d6776665a258d4-3439071.png" alt="img">

<h3 id="函数调用优化"><a href="#函数调用优化" class="headerlink" title="函数调用优化"></a>函数调用优化</h3><ul>
<li>无栈内存管理：自己维护变量栈（内存池），避免 Go 函数栈扩展。</li>
<li>自动生成跳转表，加速 generic decoding 的分支跳转。</li>
<li>使用寄存器传参：将使用频繁的变量放到固定的寄存器上（如 json buffer、结构体指针），尽量避免 memory load &amp; store。</li>
<li>重写函数调用：由于汇编函数不能内联到 Go 函数中，函数调用引入的开销甚至会抵消 SIMD 带来的性能提升，因此在 JIT 中重新实现了一组轻量级的函数调用（维护全局函数表+函数 offset）。</li>
</ul>
<h2 id="业务实践"><a href="#业务实践" class="headerlink" title="业务实践"></a>业务实践</h2><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>由于 Sonic 优化的是 json 操作，所以在 json 操作的 cpu 开销占比较大的服务场景中收益会比较明显。比如网关、转发和入口服务等。</p>
<h3 id="快速试用"><a href="#快速试用" class="headerlink" title="快速试用"></a>快速试用</h3><p>为了较小侵入地验证 Sonic 会对服务产生的性能提升，评估是否值得切换。推荐使用<a target="_blank" rel="noopener" href="https://github.com/brahma-adshonor/gohook">brahma-adshonor&#x2F;gohook</a> 工具库，内部大概实现是向被 hook 的函数地址中写入跳转指令，直接跳转到新的函数地址。</p>
<p>使用方式：在 main 函数的入口处 hook 当前使用的 json 库函数为 Sonic 中对等函数。hook 是函数级的，因此可以具体验证具体函数的性能提升；当人出于对某些函数的不信任、或者自己有性能更优异或更稳定的实现，也可以部分函数使用 Sonic。但需要注意，它未经过生产环境验证，建议仅测试使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/brahma-adshonor/gohook&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在main函数的入口hook当前使用的json库（如encoding/json）</span></span><br><span class="line">    gohook.Hook(json.Marshal, sonic.Marshal, <span class="literal">nil</span>)</span><br><span class="line">    gohook.Hook(json.Unmarshal, sonic.Unmarshal, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="收益情况"><a href="#收益情况" class="headerlink" title="收益情况"></a>收益情况</h3><p>截止 2022 年 1 月份，Sonic 已应用于抖音，今日头条等服务，累计为字节节省了数十万核。下图为字节某服务使用 Sonic 后高峰时段的 cpu 占用核数对比（<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247491325&idx=1&sn=e8799316d55c0951b0b54b404a3d87b8&scene=21#wechat_redirect">图来源</a>）。在生产环境中，Sonic 中也验证了良好的收益，服务高峰期占用核数减少将近三分之一：</p>
<img src="/2023/05/09/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/Go/Go%20JSON%20%E4%B8%89%E6%96%B9%E5%8C%85%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/f3f7d5323e0cdcfc07a5c5ca8e7b8677-3430367.png" alt="img">

<h3 id="使用事项"><a href="#使用事项" class="headerlink" title="使用事项"></a>使用事项</h3><h4 id="HTML-Escape"><a href="#HTML-Escape" class="headerlink" title="HTML Escape"></a>HTML Escape</h4><p>标准库中默认会开启 html Escape，而 Sonic 出于性能损耗默认不开启</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEncode</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;&amp;&amp;&quot;</span>: <span class="string">&quot;&lt;&gt;&quot;</span>&#125;</span><br><span class="line">  <span class="comment">// 标准库</span></span><br><span class="line">  <span class="keyword">var</span> w1 = bytes.NewBuffer(<span class="literal">nil</span>)</span><br><span class="line">  enc1 := json.NewEncoder(w1)</span><br><span class="line">  err := enc1.Encode(data)</span><br><span class="line">  assert.NoError(t, err)</span><br><span class="line">    <span class="comment">// Sonic 库</span></span><br><span class="line">  <span class="keyword">var</span> w2 = bytes.NewBuffer(<span class="literal">nil</span>)</span><br><span class="line">  enc2 := encoder.NewStreamEncoder(w2)</span><br><span class="line">  err = enc2.Encode(data)</span><br><span class="line">  assert.NoError(t, err)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%v%v&quot;</span>, w1.String(), w2.String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">&#123;<span class="string">&quot;\u0026\u0026&quot;</span>:<span class="string">&quot;\u003c\u003e&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;&amp;&amp;&quot;</span>:<span class="string">&quot;&lt;&gt;&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>若需要开启，可以通过下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/bytedance/sonic/encoder&quot;</span></span><br><span class="line"></span><br><span class="line">v := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;&amp;&amp;&quot;</span>:<span class="string">&quot;&lt;&gt;&quot;</span>&#125;</span><br><span class="line">ret, err := encoder.Encode(v, EscapeHTML) <span class="comment">// ret == `&#123;&quot;\u0026\u0026&quot;:&#123;&quot;X&quot;:&quot; \u003e&quot;&#125;&#125;`</span></span><br><span class="line"></span><br><span class="line">enc := encoder.NewStreamEncoder(w)</span><br><span class="line">enc.SetEscapeHTML(<span class="literal">true</span>)</span><br><span class="line">err := enc.Encode(obj)</span><br></pre></td></tr></table></figure>

<h4 id="大型模式问题"><a href="#大型模式问题" class="headerlink" title="大型模式问题"></a>大型模式问题</h4><p>由于 Sonic 使用 golang-asm 作为 JIT 汇编器，这不太适合运行时编译，因此首次运行大型模式可能会导致请求超时甚至处理 OOM。为了获得更好的稳定性，建议在 Marshal（）&#x2F;Unmarshal（）之前使用 Pretouch（）来处理大型模式或紧凑内存应用程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/bytedance/sonic&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/bytedance/sonic/option&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> v HugeStruct</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For most large types (nesting depth &lt;= option.DefaultMaxInlineDepth)</span></span><br><span class="line">    err := sonic.Pretouch(reflect.TypeOf(v))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with more CompileOption...</span></span><br><span class="line">    err := sonic.Pretouch(reflect.TypeOf(v),</span><br><span class="line">        <span class="comment">// If the type is too deep nesting (nesting depth &gt; option.DefaultMaxInlineDepth),</span></span><br><span class="line">        <span class="comment">// you can set compile recursive loops in Pretouch for better stability in JIT.</span></span><br><span class="line">        option.WithCompileRecursiveDepth(loop),</span><br><span class="line">        <span class="comment">// For a large nested struct, try to set a smaller depth to reduce compiling time.</span></span><br><span class="line">        option.WithCompileMaxInlineDepth(depth),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="key-排序"><a href="#key-排序" class="headerlink" title="key 排序"></a>key 排序</h4><p>Sonic 在序列化时默认是不对 key 进行排序的。json 的规范也与顺序无关，但若需要 json 是有序的，可以在序列化时选择排序的配置，大约会带来 10%的性能损耗。排序方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/bytedance/sonic&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/bytedance/sonic/encoder&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Binding map only</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">v, err := encoder.Encode(m, encoder.SortMapKeys)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or ast.Node.SortKeys() before marshal</span></span><br><span class="line"><span class="keyword">var</span> root := sonic.Get(JSON)</span><br><span class="line">err := root.SortKeys()</span><br></pre></td></tr></table></figure>

<h4 id="暂不支持-arm-架构"><a href="#暂不支持-arm-架构" class="headerlink" title="暂不支持 arm 架构"></a>暂不支持 arm 架构</h4><p>现象：本地用 Mac M1 无法编译成功解决方案，可参考 <a target="_blank" rel="noopener" href="https://github.com/bytedance/sonic#compatibility">sonic-compatibility</a>，在编译时通过添加以下参数: GOARCH&#x3D;amd64，可解决编译失败的问题，但本地环境依旧没法支持 Debug 操作；</p>
<p>官方在 <a target="_blank" rel="noopener" href="https://github.com/bytedance/sonic/issues/172">issue172</a> 中表示考虑到内部实现的确很难搞，但还是有望在 Sonic V2 大版本中支持。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，业务选型上需要根据具体情况、不同领域的业务使用场景和发展趋势进行选择，综合考虑各方面因素。 例如：如果业务只是简单的解析 http 请求返回的 json 串的部分字段，并且字段都是确定的，偶尔需要搜索功能，那 Gjson 是很不错的选择。</p>
<p>以下是一些个人观点，仅供参考：</p>
<ul>
<li><strong>不太推荐使用 Jsoniter 库，</strong>原因在于: Go 1.8 之前，官方 Json 库的性能就收到多方诟病。不过随着 Go 版本的迭代，标准 json 库的性能也越来越高，Jsonter 的性能优势也越来越窄。如果希望有极致的性能，应该选择 Easyjson 等方案而不是 Jsoniter，而且 Jsoniter 近年已经不活跃了。</li>
<li><strong>比较推荐使用 Sonic 库</strong>，因不论从性能和功能总体而言，Sonic 的表现的确很亮眼；此外，通过了解 Sonic 的内部实现原理，提供一种对于 cpu 密集性的操作的优化“野路子“，即：通过编写高性能的 C 代码并经过优化编译后供 Golang 直接调用。但其实并不新鲜，因为实际上 Go 源码中的一些 cpu 密集型操作底层就是编译成了汇编后使用的，如：crypto 和 math。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.luozhiyun.com/archives/535">深入 Go 中各个高性能 JSON 解析库</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1820473">Go 语言原生的 json 包有什么问题？如何更好地处理 JSON 数据？</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/goccy/go-json#how-it-works">go-json#how-it-works</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247491325&idx=1&sn=e8799316d55c0951b0b54b404a3d87b8&scene=21#wechat_redirect">sonic ：基于 JIT 技术的开源全场景高性能 JSON 库</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/bytedance/sonic/blob/main/INTRODUCTION.md">Introduction to Sonic</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/bytedance/sonic@v1.8.3#section-readme">bytedance&#x2F;sonic-readme</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/586050976">为字节节省数十万核的 json 库 sonic</a></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zhao520a1a.github.io">Golden</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhao520a1a.github.io/2023/05/09/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/Go/Go%20JSON%20%E4%B8%89%E6%96%B9%E5%8C%85%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/">https://zhao520a1a.github.io/2023/05/09/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/Go/Go%20JSON%20%E4%B8%89%E6%96%B9%E5%8C%85%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhao520a1a.github.io" target="_blank">发光の金子吖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a></div><div class="post_share"><div class="social-share" data-image="https://cms.halovina.com/wp-content/uploads/2021/03/golang-json.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/14/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/%E8%A7%A3%E6%9E%90%E4%B8%80%E5%BC%A0%E6%80%9D%E7%BB%B4%E8%84%91%E5%9B%BE%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86%EF%BC%9F/" title="解析一张思维脑图背后的秘密？"><img class="cover" src="https://pica.zhimg.com/cfa176b783a272bff21a9acb14cbf3b4_1440w.jpg?source=172ae18b" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">解析一张思维脑图背后的秘密？</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/02/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/%E6%8F%90%E6%95%88%E5%B8%B8%E8%AF%86/" title="提效常识"><img class="cover" src="https://5b0988e595225.cdn.sohucs.com/images/20180702/8210193a4448400b8aa6cdb214899d78.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">提效常识</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/10/21/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/Go%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="Go 使用指南"><img class="cover" src="https://contentstatic.techgig.com/photo/82278297/5-top-advantages-of-using-golang-programming-language.jpg?35743" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">Go 使用指南</div></div></a></div><div><a href="/2021/08/21/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/GO%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%80%BB%E7%BB%93%EF%BC%88%E7%A7%81%E8%97%8F%EF%BC%89/" title="代码风格规范"><img class="cover" src="https://github.com/zhao520a1a/zhao520a1a.github.io/blob/hexo/source/cover/Go.png?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-21</div><div class="title">代码风格规范</div></div></a></div><div><a href="/2021/10/09/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Go%20%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E5%BB%BA%E8%AE%AE/" title="Go 可维护性建议"><img class="cover" src="https://github.com/zhao520a1a/zhao520a1a.github.io/blob/hexo/source/cover/Go-design.png?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-09</div><div class="title">Go 可维护性建议</div></div></a></div><div><a href="/2021/03/20/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/Go%20%E5%86%AC%E5%A4%8F%E4%BB%A4%E6%97%B6%E8%BD%AC%E6%8D%A2/" title="Go读取Excel数据"><img class="cover" src="https://raw.githubusercontent.com/qax-os/excelize/7c221cf29531fcd38871d3295f4b511029cb4282/excelize.svg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-20</div><div class="title">Go读取Excel数据</div></div></a></div><div><a href="/2021/09/20/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/Go%20%E8%AF%BB%E5%8F%96%20Excel%20%E6%95%B0%E6%8D%AE/" title="Go读取Excel数据"><img class="cover" src="https://raw.githubusercontent.com/qax-os/excelize/7c221cf29531fcd38871d3295f4b511029cb4282/excelize.svg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-20</div><div class="title">Go读取Excel数据</div></div></a></div><div><a href="/2022/05/01/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/Go/Go%20GC%E7%AF%87/" title="Go GC篇"><img class="cover" src="https://pica.zhimg.com/v2-bef3e615ddc817511f2bddb939920468_720w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-01</div><div class="title">Go GC篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Golden</div><div class="author-info__description">一个乐观的悲观主义者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/334383730"><i class="fab fa-bilibili"></i><span>关注一下</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhao520a1a" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/334383730" target="_blank" title="B 站"><i class="fab fa-bilibili"></i></a><a class="social-icon" href="https://zhao520a1a.github.io/about/index/qrCode.png" target="_blank" title="微信公众号"><i class="fab fa-weixin"></i></a><a class="social-icon" href="https://www.processon.com/u/5ab9cb2de4b018c271cab8d4/profile" target="_blank" title="ProcessOn"><i class="far fa-lightbulb"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">喜欢即可关注，关注即可进步，OVER!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3-Go-%E6%A0%87%E5%87%86%E5%BA%93%E5%90%97%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">你真的了解 Go 标准库吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%EF%BC%8C%E6%A0%87%E5%87%86%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E8%B6%B3%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">为什么使用第三方库，标准库有哪些不足？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%84%E6%B5%8B%E4%B8%89%E6%96%B9%E5%BA%93"><span class="toc-number">2.</span> <span class="toc-text">评测三方库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86"><span class="toc-number">2.1.</span> <span class="toc-text">评判标准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E8%AF%84%E6%B5%8B"><span class="toc-number">2.2.</span> <span class="toc-text">功能评测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">特点分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B"><span class="toc-number">2.4.</span> <span class="toc-text">性能评测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-number">3.</span> <span class="toc-text">常见优化思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E5%9E%8B%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="toc-number">3.1.</span> <span class="toc-text">定型编解码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E7%BB%84%E8%A3%85"><span class="toc-number">3.1.1.</span> <span class="toc-text">动态函数组装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">减少函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-gen"><span class="toc-number">3.1.3.</span> <span class="toc-text">code-gen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT"><span class="toc-number">3.1.4.</span> <span class="toc-text">JIT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="toc-number">3.2.</span> <span class="toc-text">泛型编解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E7%BC%96%E7%A0%81%E7%BC%93%E5%AD%98%E5%8C%BA"><span class="toc-number">3.3.</span> <span class="toc-text">复用编码缓存区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-Sonic-%E5%BA%93"><span class="toc-number">4.</span> <span class="toc-text">案例 Sonic 库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E8%B0%83%E7%A0%94"><span class="toc-number">4.1.</span> <span class="toc-text">原理调研</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SIMD"><span class="toc-number">4.1.1.</span> <span class="toc-text">SIMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#asm2asm"><span class="toc-number">4.1.2.</span> <span class="toc-text">asm2asm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT-%E6%B1%87%E7%BC%96"><span class="toc-number">4.1.3.</span> <span class="toc-text">JIT 汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RCU-cache"><span class="toc-number">4.1.4.</span> <span class="toc-text">RCU cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-AST"><span class="toc-number">4.1.5.</span> <span class="toc-text">自定义 AST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.6.</span> <span class="toc-text">函数调用优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.2.</span> <span class="toc-text">业务实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.2.1.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%AF%95%E7%94%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">快速试用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E7%9B%8A%E6%83%85%E5%86%B5"><span class="toc-number">4.2.3.</span> <span class="toc-text">收益情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.2.4.</span> <span class="toc-text">使用事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML-Escape"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">HTML Escape</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%9E%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">大型模式问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#key-%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">key 排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%82%E4%B8%8D%E6%94%AF%E6%8C%81-arm-%E6%9E%B6%E6%9E%84"><span class="toc-number">4.2.4.4.</span> <span class="toc-text">暂不支持 arm 架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/04/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/AI/%E7%99%BD%E8%AF%9D%E7%A7%91%E6%99%AE%20%7C%20AI%E7%BB%98%E7%94%BB%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E7%9A%84%EF%BC%9F/" title="白话科普 | AI绘画是如何生成图像的？"><img src="https://cdn.modevol.com/picture_bed/SD%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE/a%20%284%29.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="白话科普 | AI绘画是如何生成图像的？"/></a><div class="content"><a class="title" href="/2023/10/04/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/AI/%E7%99%BD%E8%AF%9D%E7%A7%91%E6%99%AE%20%7C%20AI%E7%BB%98%E7%94%BB%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E7%9A%84%EF%BC%9F/" title="白话科普 | AI绘画是如何生成图像的？">白话科普 | AI绘画是如何生成图像的？</a><time datetime="2023-10-03T16:00:00.000Z" title="发表于 2023-10-04 00:00:00">2023-10-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/14/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/%E8%A7%A3%E6%9E%90%E4%B8%80%E5%BC%A0%E6%80%9D%E7%BB%B4%E8%84%91%E5%9B%BE%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86%EF%BC%9F/" title="解析一张思维脑图背后的秘密？"><img src="https://pica.zhimg.com/cfa176b783a272bff21a9acb14cbf3b4_1440w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="解析一张思维脑图背后的秘密？"/></a><div class="content"><a class="title" href="/2023/08/14/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/%E8%A7%A3%E6%9E%90%E4%B8%80%E5%BC%A0%E6%80%9D%E7%BB%B4%E8%84%91%E5%9B%BE%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86%EF%BC%9F/" title="解析一张思维脑图背后的秘密？">解析一张思维脑图背后的秘密？</a><time datetime="2023-08-13T16:00:00.000Z" title="发表于 2023-08-14 00:00:00">2023-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/09/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/Go/Go%20JSON%20%E4%B8%89%E6%96%B9%E5%8C%85%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/" title="Go JSON 三方包哪家强？"><img src="https://cms.halovina.com/wp-content/uploads/2021/03/golang-json.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go JSON 三方包哪家强？"/></a><div class="content"><a class="title" href="/2023/05/09/%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/Go/Go%20JSON%20%E4%B8%89%E6%96%B9%E5%8C%85%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/" title="Go JSON 三方包哪家强？">Go JSON 三方包哪家强？</a><time datetime="2023-05-08T16:00:00.000Z" title="发表于 2023-05-09 00:00:00">2023-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/02/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/%E6%8F%90%E6%95%88%E5%B8%B8%E8%AF%86/" title="提效常识"><img src="https://5b0988e595225.cdn.sohucs.com/images/20180702/8210193a4448400b8aa6cdb214899d78.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="提效常识"/></a><div class="content"><a class="title" href="/2023/05/02/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/%E6%8F%90%E6%95%88%E5%B8%B8%E8%AF%86/" title="提效常识">提效常识</a><time datetime="2023-05-01T16:00:00.000Z" title="发表于 2023-05-02 00:00:00">2023-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/02/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/Copilot/" title="copilot 使用指南"><img src="https://rewind.com/wp-content/uploads/2022/03/github-copilot-logo.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="copilot 使用指南"/></a><div class="content"><a class="title" href="/2023/02/02/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/Copilot/" title="copilot 使用指南">copilot 使用指南</a><time datetime="2023-02-01T16:00:00.000Z" title="发表于 2023-02-02 00:00:00">2023-02-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Golden</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>